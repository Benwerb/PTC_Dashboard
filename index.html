<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PTC Dashboard</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            background-color: #f5f5f5;
        }

        h1 {
            text-align: center;
            margin-bottom: 20px;
            color: #333;
        }

        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        label {
            font-weight: bold;
            color: #555;
        }

        select {
            padding: 8px 12px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: white;
            cursor: pointer;
            font-size: 14px;
            min-width: 200px;
        }

        select:hover {
            border-color: #999;
        }

        select[multiple] {
            min-height: 100px;
        }

        button {
            padding: 8px 16px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: #4CAF50;
            color: white;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
        }

        button:hover {
            background-color: #45a049;
        }

        input[type="file"] {
            padding: 8px 12px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: white;
            cursor: pointer;
            font-size: 14px;
        }

        input[type="file"]:hover {
            border-color: #999;
        }

        #plot {
            width: 100%;
            height: calc(100vh - 200px);
            min-height: 500px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
            font-size: 18px;
        }

        .error {
            color: #d32f2f;
            padding: 20px;
            background-color: #ffebee;
            border-radius: 4px;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <h1>PTC Dashboard</h1>

    <div class="controls">
        <div class="control-group">
            <label for="fileUpload">Upload CSV:</label>
            <input type="file" id="fileUpload" accept=".csv" multiple>
        </div>

        <div class="control-group">
            <label for="fileSelect">Files:</label>
            <select id="fileSelect">
                <option value="">No files uploaded</option>
            </select>
        </div>

        <div class="control-group">
            <label for="xAxisSelect">X-Axis:</label>
            <select id="xAxisSelect">
                <option>Select a file first</option>
            </select>
        </div>

        <div class="control-group">
            <label for="yAxisSelect">Y-Axis (hold Ctrl/Cmd for multiple):</label>
            <select id="yAxisSelect" multiple>
                <option>Select a file first</option>
            </select>
        </div>

        <div class="control-group">
            <button id="fixAxisBtn">Fix Axis Limits</button>
        </div>
    </div>

    <div id="plot"></div>

    <script>
        let uploadedFiles = {};
        let currentData = null;
        let currentColumns = [];

        // Parse CSV data, skipping metadata rows
        function parseCSV(text) {
            const lines = text.split('\n');

            if (lines.length === 0) {
                throw new Error('Empty CSV file');
            }

            // First line is headers
            const headers = lines[0].split(',').map(h => h.trim());

            // Skip metadata rows (rows starting with "H") and get data rows
            const dataRows = [];
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line && !line.startsWith('H,') && !line.startsWith('H ')) {
                    dataRows.push(line);
                }
            }

            // Parse data rows
            const data = {};
            headers.forEach(header => {
                data[header] = [];
            });

            dataRows.forEach(row => {
                const values = parseCSVRow(row);
                if (values.length === headers.length) {
                    headers.forEach((header, index) => {
                        let value = values[index];

                        // Convert date/time strings to Date objects for plotting
                        if (header === 'DATE TIME' || header === 'Labview Date/Time') {
                            value = value || null;
                        } else {
                            // Try to convert to number
                            const num = parseFloat(value);
                            value = isNaN(num) ? value : num;
                        }

                        data[header].push(value);
                    });
                }
            });

            return { headers, data };
        }

        // Parse a CSV row handling quoted values
        function parseCSVRow(row) {
            const values = [];
            let current = '';
            let inQuotes = false;

            for (let i = 0; i < row.length; i++) {
                const char = row[i];

                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    values.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }

            values.push(current.trim());
            return values;
        }

        // Update plot with selected data
        function updatePlot(fixedRanges = null) {
            const fileSelect = document.getElementById('fileSelect');
            const xAxisSelect = document.getElementById('xAxisSelect');
            const yAxisSelect = document.getElementById('yAxisSelect');

            if (!currentData || !fileSelect.value || !xAxisSelect.value) {
                return;
            }

            // Get selected Y columns
            const selectedYColumns = Array.from(yAxisSelect.selectedOptions).map(opt => opt.value);

            if (selectedYColumns.length === 0) {
                return;
            }

            const xColumn = xAxisSelect.value;

            // Create a trace for each selected Y column
            const traces = selectedYColumns.map((yColumn, index) => {
                return {
                    x: currentData.data[xColumn],
                    y: currentData.data[yColumn],
                    mode: 'lines+markers',
                    type: 'scatter',
                    name: yColumn,
                    marker: { size: 4 },
                    line: { width: 1 }
                };
            });

            // Build y-axis title
            const yAxisTitle = selectedYColumns.length === 1
                ? selectedYColumns[0]
                : 'Multiple Y-Axes';

            const layout = {
                title: fileSelect.value,
                xaxis: { title: xColumn },
                yaxis: { title: yAxisTitle },
                hovermode: 'closest',
                margin: { t: 50, r: 50, b: 50, l: 80 },
                showlegend: selectedYColumns.length > 1
            };

            // Apply fixed ranges if provided
            if (fixedRanges) {
                if (fixedRanges.xaxis) {
                    layout.xaxis.range = fixedRanges.xaxis;
                }
                if (fixedRanges.yaxis) {
                    layout.yaxis.range = fixedRanges.yaxis;
                }
            }

            const config = {
                responsive: true,
                displayModeBar: true,
                displaylogo: false
            };

            Plotly.newPlot('plot', traces, layout, config);
        }

        // Load selected file from uploaded files
        function loadFile(filename) {
            const plotDiv = document.getElementById('plot');

            try {
                if (!uploadedFiles[filename]) {
                    throw new Error('File not found');
                }

                currentData = uploadedFiles[filename];
                currentColumns = currentData.headers;

                // Update axis selectors
                updateAxisSelectors();

                // Update plot
                updatePlot();
            } catch (error) {
                console.error('Error loading file:', error);
                plotDiv.innerHTML = `<div class="error">Error loading file: ${error.message}</div>`;
            }
        }

        // Handle file upload
        async function handleFileUpload(files) {
            const fileSelect = document.getElementById('fileSelect');
            const plotDiv = document.getElementById('plot');

            plotDiv.innerHTML = '<div class="loading">Loading files...</div>';

            try {
                for (const file of files) {
                    const text = await file.text();
                    const parsedData = parseCSV(text);
                    uploadedFiles[file.name] = parsedData;
                }

                // Update file dropdown
                fileSelect.innerHTML = '';
                const fileNames = Object.keys(uploadedFiles).sort((a, b) => b.localeCompare(a));

                fileNames.forEach(filename => {
                    const option = document.createElement('option');
                    option.value = filename;
                    option.textContent = filename;
                    fileSelect.appendChild(option);
                });

                // Load the first file (most recent)
                if (fileNames.length > 0) {
                    fileSelect.value = fileNames[0];
                    loadFile(fileNames[0]);
                }

            } catch (error) {
                console.error('Error uploading files:', error);
                plotDiv.innerHTML = `<div class="error">Error uploading files: ${error.message}</div>`;
            }
        }

        // Update axis selector dropdowns
        function updateAxisSelectors() {
            const xAxisSelect = document.getElementById('xAxisSelect');
            const yAxisSelect = document.getElementById('yAxisSelect');

            // Clear existing options
            xAxisSelect.innerHTML = '';
            yAxisSelect.innerHTML = '';

            // Add options for each column
            currentColumns.forEach(column => {
                const xOption = document.createElement('option');
                xOption.value = column;
                xOption.textContent = column;
                xAxisSelect.appendChild(xOption);

                const yOption = document.createElement('option');
                yOption.value = column;
                yOption.textContent = column;
                yAxisSelect.appendChild(yOption);
            });

            // Set default values
            if (currentColumns.includes('DATE TIME')) {
                xAxisSelect.value = 'DATE TIME';
            }
            if (currentColumns.includes('VRS VOLTS')) {
                const vrsOption = Array.from(yAxisSelect.options).find(opt => opt.value === 'VRS VOLTS');
                if (vrsOption) {
                    vrsOption.selected = true;
                }
            }
        }

        // Calculate percentile of an array
        function percentile(arr, p) {
            const sorted = arr.filter(x => typeof x === 'number' && !isNaN(x)).sort((a, b) => a - b);
            if (sorted.length === 0) return null;

            const index = (p / 100) * (sorted.length - 1);
            const lower = Math.floor(index);
            const upper = Math.ceil(index);
            const weight = index % 1;

            if (lower === upper) {
                return sorted[lower];
            }

            return sorted[lower] * (1 - weight) + sorted[upper] * weight;
        }

        // Fix axis limits using sensible ranges around the median
        function fixAxisLimits() {
            const xAxisSelect = document.getElementById('xAxisSelect');
            const yAxisSelect = document.getElementById('yAxisSelect');

            if (!currentData || !xAxisSelect.value) {
                return;
            }

            const selectedYColumns = Array.from(yAxisSelect.selectedOptions).map(opt => opt.value);
            if (selectedYColumns.length === 0) {
                return;
            }

            const xColumn = xAxisSelect.value;

            // Calculate sensible ranges using 5th and 95th percentiles
            // This removes the extreme 5% on each end (outliers/spikes)
            let xRange = null;
            let yRange = null;

            // X-axis range (if numeric data)
            const xData = currentData.data[xColumn];
            const numericXData = xData.filter(x => typeof x === 'number' && !isNaN(x));

            if (numericXData.length > 0) {
                const xMin = percentile(numericXData, 5);
                const xMax = percentile(numericXData, 95);

                if (xMin !== null && xMax !== null) {
                    // Add 5% padding on each side
                    const xPadding = (xMax - xMin) * 0.05;
                    xRange = [xMin - xPadding, xMax + xPadding];
                }
            }

            // Y-axis range - combine all selected Y columns
            let allYValues = [];
            selectedYColumns.forEach(yColumn => {
                const yData = currentData.data[yColumn];
                const numericYData = yData.filter(y => typeof y === 'number' && !isNaN(y));
                allYValues = allYValues.concat(numericYData);
            });

            if (allYValues.length > 0) {
                const yMin = percentile(allYValues, 5);
                const yMax = percentile(allYValues, 95);

                if (yMin !== null && yMax !== null) {
                    // Add 5% padding on each side
                    const yPadding = (yMax - yMin) * 0.05;
                    yRange = [yMin - yPadding, yMax + yPadding];
                }
            }

            // Update plot with fixed ranges
            updatePlot({
                xaxis: xRange,
                yaxis: yRange
            });
        }

        // Initialize dashboard
        function init() {
            const fileUpload = document.getElementById('fileUpload');
            const fileSelect = document.getElementById('fileSelect');
            const fixAxisBtn = document.getElementById('fixAxisBtn');

            // Add event listeners
            fileUpload.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    handleFileUpload(Array.from(e.target.files));
                }
            });

            fileSelect.addEventListener('change', (e) => {
                if (e.target.value) {
                    loadFile(e.target.value);
                }
            });

            document.getElementById('xAxisSelect').addEventListener('change', () => updatePlot());
            document.getElementById('yAxisSelect').addEventListener('change', () => updatePlot());

            fixAxisBtn.addEventListener('click', fixAxisLimits);

            // Show initial message
            document.getElementById('plot').innerHTML =
                '<div class="loading">Upload one or more CSV files to get started</div>';
        }

        // Start the application
        init();
    </script>
</body>
</html>
